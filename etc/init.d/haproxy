#!/usr/bin/env ruby
### BEGIN INIT INFO
# Provides:          haproxy
# Required-Start:    $local_fs $network
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: fast and reliable load balancing reverse proxy
# Description:       This file should be used to start and stop haproxy.
### END INIT INFO

# Adapted from the haproxy bash init script by Arnaud Cornet <acornet@debian.org>
require 'rubygems'
require 'logging'

HAPROXY_NAME = "HAProxy"
HAPROXY = "/usr/local/haproxy/current/sbin/haproxy"
HAPROXY_PID = "/var/run/haproxy.pid"
HAPROXY_CONFIG = "/usr/local/haproxy/current/etc/haproxy.cfg"
HAPROXY_OPTS = ""

HEALTH_CHECK = "/usr/local/haproxy/health_checks/hadb.rb"
HEALTH_CHECK_PID = "/usr/local/haproxy/health_checks/hadb.pid"
LOG_FILE = '/usr/local/haproxy/health_checks/hadb.log'

Logging.init :debug, :info, :warn, :error, :fatal
layout = Logging::Layouts::Pattern.new :pattern => "[%d][%l][%c] %m\n"
@logger = Logging.logger['init']
@logger.add_appenders(
  Logging.appenders.file(LOG_FILE, :layout => layout),
  Logging.appenders.stdout
)
@logger.level = :info


def kill_pids(pid_file)
  @logger.info "killing pid file: #{pid_file}"

  # just wait a second to allow any handles to be released
  # otherwise it just seems to open an empty file and so kills nothing.
  # example is when db driver has syntax error.
  sleep 2
  if File.exist? pid_file
    File.open(pid_file) do |file|
      while pid = file.gets
        begin
          Process.kill(:TERM, pid.to_i) 
          @logger.info "init killing: ##{pid}"
        rescue => e 
          @logger.error "init errror killing: ##{pid} #{e.message}"
        end
      end
    end
    File.delete pid_file
  end
end


def haproxy_start
  @logger.info "------------------------------"
  begin

    raise "HAProxy db driver failed to start. Aborting HAProxy startup..." unless system HEALTH_CHECK

    # system returns bool vs `` which returns stdout string. so use system as check but throw away output otherwise
    # it shows up messily on console. lastly, grep itself appears in this search so throw it out.
    raise "HAProxy db driver started, but doesn't seem to be running. aborting..." unless system "ps aux | grep #{HEALTH_CHECK} | grep -v grep > /dev/null"
    @logger.info "HAProxy db driver up and running. Starting HAProxy..."

    raise "HAProxy failed to start. Killing db drivers..." unless  system "start-stop-daemon --start --pidfile #{HAPROXY_PID} --exec #{HAPROXY} -- -f #{HAPROXY_CONFIG} -D #{HAPROXY_OPTS} -p #{HAPROXY_PID}"  
    true
  rescue => e

    @logger.error e.message
    kill_pids HAPROXY_PID
    kill_pids HEALTH_CHECK_PID
    false
  end
end

def haproxy_stop
  kill_pids HEALTH_CHECK_PID
  kill_pids HAPROXY_PID

  true
end

def haproxy_reload
	system "#{HAPROXY} -f #{HAPROXY_CONFIG} -p #{HAPROXY_PID} -D #{HAPROXY_OPTS} -sf #{IO.read(HAPROXY_PID)}"
  
end

def haproxy_status

  case
	when !File.exist?(HAPROXY_PID)
	  "not running"
  else

# needs reworking to check if process but no pid and vice versa
# bonus points for reconstituting a pid if missing on running process etc
# there should be a gem for pid file management
#	for pid in $(cat $PIDFILE) ; do
#		if ! ps --no-headers p "$pid" | grep haproxy > /dev/null ; then
#			# program running, bogus pidfile
#			return 1
#		fi

    "running"
  end

end


case ARGV[0]
when "start"
	if haproxy_start
    @logger.info "#{HAPROXY_NAME} started"
  else
    @logger.error "#{HAPROXY_NAME} failed to start."
  end

when "stop"
  if haproxy_stop
    @logger.info "#{HAPROXY_NAME} stopped"
  end

when "reload", "force-reload"
  if haproxy_reload
    @logger.info "#{HAPROXY_NAME} reloaded"
  end

when "restart"
  if haproxy_stop && haproxy_start
    @logger.info "#{HAPROXY_NAME} restarted"
  end

when "status"
  @logger.info "#{HAPROXY_NAME} is #{haproxy_status}"

else
	@logger.info "Usage: /etc/init.d/haproxy {start|stop|reload|restart|status}"
end

